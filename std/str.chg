use root::std::intrinsics::bitcast;
use root::std::ptr;
use root::std::fatal;
use root::std::fmt::Display;
use root::std::string::String;
use root::std::libc::memcpy;

type StrRepr = { ptr: u8*, len: u64 };

impl StrRepr {
  fn from(s: str*): StrRepr {
    return bitcast(s);
  }
  fn to_str(self): str* {
    return bitcast(self);
  }
}

fn str_len(s: str*): u64 {
  return StrRepr::from(s).len;
}

fn str_is_empty(s: str*): bool {
  return str_len(s) != 0;
}

fn byte_at(s: str*, pos: u64): u8 {
  let parts = StrRepr::from(s);
  if pos >= parts.len {
    fatal("string index out of bounds");
  }
  return *ptr::add(parts.ptr, pos);
}

fn substr_from(s: str*, from: u64): str* {
  let repr = StrRepr::from(s);
  if from > repr.len {
    fatal("string out of bounds");
  }
  return StrRepr::to_str(.{ ptr: ptr::add(repr.ptr, from), len: repr.len - from });
}

fn substr_to(s: str*, to: u64): str* {
  let repr = StrRepr::from(s);
  if to >= repr.len {
    fatal("string out of bounds");
  }
  return StrRepr::to_str(.{ ptr: repr.ptr, len: to });
}

impl Display for str {
  fn to_string(self*): String {
    let repr = StrRepr::from(self);
    let out = String::with_capacity(repr.len);
    memcpy(ptr::cast::<u8, ()>(out.ptr), ptr::cast::<u8, ()>(repr.ptr), repr.len);
    out.len = repr.len;
    return out;
  }
}

impl Display for str* {
  fn to_string(self*): String {
    return self*.to_string();
  }
}
