expr @ 12:10 12:17 => extern "intrinsic" fn bitcast(...)
expr @ 12:18 12:19 => str*
expr @ 12:10 12:20 => StrRepr<>
expr @ 12:3 12:20 => never
expr @ 11:31 14:0 => ()
expr @ 16:15 16:23 => fn str_repr(...)
expr @ 16:24 16:25 => str*
expr @ 16:15 16:26 => StrRepr<>
expr @ 17:3 17:8 => extern "C" fn write(...)
expr @ 17:9 17:10 => i32
expr @ 17:12 17:17 => StrRepr<>
expr @ 17:12 17:21 => i8*
expr @ 17:23 17:28 => StrRepr<>
expr @ 17:23 17:32 => u64
expr @ 17:3 17:33 => i32
expr @ 15:19 19:0 => ()
expr @ 23:18 23:25 => extern "intrinsic" fn bitcast(...)
expr @ 23:26 23:27 => i32
expr @ 23:18 23:28 => T*
expr @ 23:35 23:36 => u64
expr @ 23:46 23:47 => u64
expr @ 23:10 23:52 => {ptr: T*,len: u64,cap: u64}
expr @ 23:3 23:52 => never
expr @ 22:24 25:0 => ()
expr @ 27:6 27:11 => u64
expr @ 27:17 27:20 => Vec<T>*
expr @ 27:16 27:20 => Vec<T>
expr @ 27:16 27:25 => u64
expr @ 27:6 27:25 => bool
expr @ 28:5 28:10 => fn print(...)
expr @ 28:11 28:32 => str*
expr @ 28:5 28:33 => ()
expr @ 29:5 29:10 => extern "C" fn abort(...)
expr @ 29:5 29:12 => ()
expr @ 27:26 30:4 => ()
expr @ 27:3 30:4 => ()
expr @ 31:27 31:28 => extern "intrinsic" fn bitcast(...)
expr @ 31:46 31:47 => extern "intrinsic" fn bitcast(...)
expr @ 31:50 31:53 => Vec<T>*
expr @ 31:49 31:53 => Vec<T>
expr @ 31:49 31:58 => T*
expr @ 31:46 31:59 => u64
expr @ 31:62 31:67 => u64
expr @ 31:46 31:67 => u64
expr @ 31:27 31:68 => T*
expr @ 31:3 31:68 => never
expr @ 26:40 33:0 => ()
expr @ 35:6 35:13 => extern "intrinsic" fn bitcast(...)
expr @ 35:16 35:19 => Vec<T>*
expr @ 35:15 35:19 => Vec<T>
expr @ 35:15 35:24 => T*
expr @ 35:6 35:25 => i32
expr @ 35:29 35:30 => i32
expr @ 35:6 35:30 => bool
expr @ 36:35 36:36 => extern "intrinsic" fn bitcast(...)
expr @ 36:37 36:43 => extern "C" fn malloc(...)
expr @ 36:44 36:45 => u64
expr @ 36:37 36:49 => ()*
expr @ 36:35 36:50 => T*
expr @ 36:7 36:10 => Vec<T>*
expr @ 36:6 36:10 => Vec<T>
expr @ 36:6 36:15 => T*
expr @ 36:6 36:50 => ()
expr @ 37:18 37:19 => u64
expr @ 37:7 37:10 => Vec<T>*
expr @ 37:6 37:10 => Vec<T>
expr @ 37:6 37:15 => u64
expr @ 37:6 37:19 => ()
expr @ 35:31 38:4 => ()
expr @ 35:3 38:4 => ()
expr @ 40:8 40:11 => Vec<T>*
expr @ 40:7 40:11 => Vec<T>
expr @ 40:7 40:16 => u64
expr @ 40:22 40:25 => Vec<T>*
expr @ 40:21 40:25 => Vec<T>
expr @ 40:21 40:30 => u64
expr @ 40:7 40:30 => bool
expr @ 41:20 41:23 => Vec<T>*
expr @ 41:19 41:23 => Vec<T>
expr @ 41:19 41:28 => u64
expr @ 41:31 41:32 => u64
expr @ 41:19 41:32 => u64
expr @ 41:7 41:10 => Vec<T>*
expr @ 41:6 41:10 => Vec<T>
expr @ 41:6 41:15 => u64
expr @ 41:6 41:32 => ()
expr @ 42:35 42:36 => extern "intrinsic" fn bitcast(...)
expr @ 42:37 42:44 => extern "C" fn realloc(...)
expr @ 42:62 42:63 => extern "intrinsic" fn bitcast(...)
expr @ 42:66 42:69 => Vec<T>*
expr @ 42:65 42:69 => Vec<T>
expr @ 42:65 42:74 => T*
expr @ 42:62 42:75 => ()*
expr @ 42:79 42:82 => Vec<T>*
expr @ 42:78 42:82 => Vec<T>
expr @ 42:78 42:87 => u64
expr @ 42:37 42:88 => ()*
expr @ 42:35 42:89 => T*
expr @ 42:7 42:10 => Vec<T>*
expr @ 42:6 42:10 => Vec<T>
expr @ 42:6 42:15 => T*
expr @ 42:6 42:89 => ()
expr @ 40:31 43:4 => ()
expr @ 40:3 43:4 => ()
expr @ 45:30 45:31 => extern "intrinsic" fn bitcast(...)
expr @ 45:49 45:50 => extern "intrinsic" fn bitcast(...)
expr @ 45:53 45:56 => Vec<T>*
expr @ 45:52 45:56 => Vec<T>
expr @ 45:52 45:61 => T*
expr @ 45:49 45:62 => u64
expr @ 45:67 45:70 => Vec<T>*
expr @ 45:66 45:70 => Vec<T>
expr @ 45:66 45:75 => u64
expr @ 45:49 45:75 => u64
expr @ 45:30 45:76 => T*
expr @ 46:10 46:15 => T
expr @ 46:4 46:7 => T*
expr @ 46:3 46:7 => T
expr @ 46:3 46:15 => ()
expr @ 47:18 47:21 => Vec<T>*
expr @ 47:17 47:21 => Vec<T>
expr @ 47:17 47:26 => u64
expr @ 47:29 47:30 => u64
expr @ 47:17 47:30 => u64
expr @ 47:5 47:8 => Vec<T>*
expr @ 47:4 47:8 => Vec<T>
expr @ 47:4 47:13 => u64
expr @ 47:4 47:30 => ()
expr @ 34:36 49:0 => ()
expr @ 52:24 52:25 => fn mk_vec(...)
expr @ 52:24 52:27 => Vec<i8>
expr @ 53:3 53:7 => fn push(...)
expr @ 53:9 53:12 => Vec<i8>
expr @ 53:8 53:12 => Vec<i8>*
expr @ 53:14 53:15 => i8
expr @ 53:3 53:19 => ()
expr @ 54:3 54:5 => fn at(...)
expr @ 54:7 54:10 => Vec<i8>
expr @ 54:6 54:10 => Vec<i8>*
expr @ 54:12 54:13 => u64
expr @ 54:3 54:17 => i8*
expr @ 51:11 56:1 => ()

declare {}* @malloc(i64)
declare {}* @realloc({}*, i64)
declare i32 @write(i32, i8*, i64)
declare void @abort()

@ct.0 = private constant [19 x i8] c"index out of bounds"

define {i8*, i64, i64} @mk_vec$LT$i8$GT$() {
prologue:
%l.0 = alloca {i8*, i64, i64}
br label %bb.0

bb.0:
%t.0 = alloca i32
store i32 0, i32* %t.0
%t.1 = bitcast i32* %t.0 to i8**
%l.1 = load i8*, i8** %t.1
%t.2 = alloca {i8*, i64, i64}
%p.3 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.2, i32 0, i32 0
store i8* %l.1, i8** %p.3
%p.4 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.2, i32 0, i32 1
store i64 0, i64* %p.4
%p.5 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.2, i32 0, i32 2
store i64 0, i64* %p.5
%t.6 = load {i8*, i64, i64}, {i8*, i64, i64}* %t.2
store {i8*, i64, i64} %t.6, {i8*, i64, i64}* %l.0
%ret.7 = load {i8*, i64, i64}, {i8*, i64, i64}* %l.0
ret {i8*, i64, i64} %ret.7

}

define void @push$LT$i8$GT$({i8*, i64, i64}* %lt.0, i8 %lt.1) {
prologue:
%l.0 = alloca {i8*, i64, i64}*
%l.1 = alloca i8
%l.17 = alloca i8*
store {i8*, i64, i64}* %lt.0, {i8*, i64, i64}** %l.0
store i8 %lt.1, i8* %l.1
br label %bb.0

bb.0:
%t.0 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.1 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.0, i32 0, i32 0
%l.3 = load i8*, i8** %t.1
%t.2 = alloca i8*
store i8* %l.3, i8** %t.2
%t.3 = bitcast i8** %t.2 to i32*
%l.2 = load i32, i32* %t.3
%l.4 = icmp eq i32 %l.2, 0
br i1 %l.4, label %bb.2, label %bb.1

bb.1:
%t.4 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.5 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.4, i32 0, i32 1
%l.7 = load i64, i64* %t.5
%t.6 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.7 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.6, i32 0, i32 2
%l.8 = load i64, i64* %t.7
%l.9 = icmp eq i64 %l.7, %l.8
br i1 %l.9, label %bb.5, label %bb.4

bb.2:
%l.6 = call {}* @malloc(i64 4)
br label %bb.3

bb.3:
%t.8 = alloca {}*
store {}* %l.6, {}** %t.8
%t.9 = bitcast {}** %t.8 to i8**
%l.5 = load i8*, i8** %t.9
%t.10 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.11 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.10, i32 0, i32 0
store i8* %l.5, i8** %t.11
%t.12 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.13 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.12, i32 0, i32 2
store i64 4, i64* %t.13
br label %bb.1

bb.4:
%t.14 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.15 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.14, i32 0, i32 0
%l.20 = load i8*, i8** %t.15
%t.16 = alloca i8*
store i8* %l.20, i8** %t.16
%t.17 = bitcast i8** %t.16 to i64*
%l.19 = load i64, i64* %t.17
%t.18 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.19 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.18, i32 0, i32 1
%l.21 = load i64, i64* %t.19
%l.22 = add i64 %l.19, %l.21
%t.20 = alloca i64
store i64 %l.22, i64* %t.20
%t.21 = bitcast i64* %t.20 to i8**
%l.18 = load i8*, i8** %t.21
store i8* %l.18, i8** %l.17
%l.23 = load i8, i8* %l.1
%t.22 = load i8*, i8** %l.17
store i8 %l.23, i8* %t.22
%t.23 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.24 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.23, i32 0, i32 1
%l.24 = load i64, i64* %t.24
%l.25 = add i64 %l.24, 1
%t.25 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.26 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.25, i32 0, i32 1
store i64 %l.25, i64* %t.26
ret void

bb.5:
%t.27 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.28 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.27, i32 0, i32 2
%l.10 = load i64, i64* %t.28
%l.11 = mul i64 %l.10, 2
%t.29 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.30 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.29, i32 0, i32 2
store i64 %l.11, i64* %t.30
%t.31 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.32 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.31, i32 0, i32 0
%l.15 = load i8*, i8** %t.32
%t.33 = alloca i8*
store i8* %l.15, i8** %t.33
%t.34 = bitcast i8** %t.33 to {}**
%l.14 = load {}*, {}** %t.34
%t.35 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.36 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.35, i32 0, i32 2
%l.16 = load i64, i64* %t.36
%l.13 = call {}* @realloc({}* %l.14, i64 %l.16)
br label %bb.6

bb.6:
%t.37 = alloca {}*
store {}* %l.13, {}** %t.37
%t.38 = bitcast {}** %t.37 to i8**
%l.12 = load i8*, i8** %t.38
%t.39 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.0
%t.40 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.39, i32 0, i32 0
store i8* %l.12, i8** %t.40
br label %bb.4

}

define {i8*, i64} @str_repr({i8*, i64} %lt.1) {
prologue:
%l.0 = alloca {i8*, i64}
%l.1 = alloca {i8*, i64}
store {i8*, i64} %lt.1, {i8*, i64}* %l.1
br label %bb.0

bb.0:
%l.3 = load {i8*, i64}, {i8*, i64}* %l.1
%t.0 = alloca {i8*, i64}
store {i8*, i64} %l.3, {i8*, i64}* %t.0
%t.1 = bitcast {i8*, i64}* %t.0 to {i8*, i64}*
%l.2 = load {i8*, i64}, {i8*, i64}* %t.1
store {i8*, i64} %l.2, {i8*, i64}* %l.0
%ret.2 = load {i8*, i64}, {i8*, i64}* %l.0
ret {i8*, i64} %ret.2

}

define void @print({i8*, i64} %lt.0) {
prologue:
%l.0 = alloca {i8*, i64}
%l.1 = alloca {i8*, i64}
store {i8*, i64} %lt.0, {i8*, i64}* %l.0
br label %bb.0

bb.0:
%l.3 = load {i8*, i64}, {i8*, i64}* %l.0
%l.2 = call {i8*, i64} @str_repr({i8*, i64} %l.3)
br label %bb.1

bb.1:
store {i8*, i64} %l.2, {i8*, i64}* %l.1
%t.0 = getelementptr {i8*, i64}, {i8*, i64}* %l.1, i32 0, i32 0
%l.5 = load i8*, i8** %t.0
%t.1 = getelementptr {i8*, i64}, {i8*, i64}* %l.1, i32 0, i32 1
%l.6 = load i64, i64* %t.1
%l.4 = call i32 @write(i32 1, i8* %l.5, i64 %l.6)
br label %bb.2

bb.2:
ret void

}

define i8* @at$LT$i8$GT$({i8*, i64, i64}* %lt.1, i64 %lt.2) {
prologue:
%l.0 = alloca i8*
%l.1 = alloca {i8*, i64, i64}*
%l.2 = alloca i64
store {i8*, i64, i64}* %lt.1, {i8*, i64, i64}** %l.1
store i64 %lt.2, i64* %l.2
br label %bb.0

bb.0:
%l.3 = load i64, i64* %l.2
%t.0 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.1
%t.1 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.0, i32 0, i32 1
%l.4 = load i64, i64* %t.1
%l.5 = icmp uge i64 %l.3, %l.4
br i1 %l.5, label %bb.2, label %bb.1

bb.1:
%t.2 = load {i8*, i64, i64}*, {i8*, i64, i64}** %l.1
%t.3 = getelementptr {i8*, i64, i64}, {i8*, i64, i64}* %t.2, i32 0, i32 0
%l.10 = load i8*, i8** %t.3
%t.4 = alloca i8*
store i8* %l.10, i8** %t.4
%t.5 = bitcast i8** %t.4 to i64*
%l.9 = load i64, i64* %t.5
%l.11 = load i64, i64* %l.2
%l.12 = add i64 %l.9, %l.11
%t.6 = alloca i64
store i64 %l.12, i64* %t.6
%t.7 = bitcast i64* %t.6 to i8**
%l.8 = load i8*, i8** %t.7
store i8* %l.8, i8** %l.0
%ret.8 = load i8*, i8** %l.0
ret i8* %ret.8

bb.2:
%l.6 = call {} bitcast(void({i8*, i64})* @print to {}({i8*, i64})*)({i8*, i64} {i8* bitcast([19 x i8]* @ct.0 to i8*), i64 19})
br label %bb.3

bb.3:
%l.7 = call {} bitcast(void()* @abort to {}()*)()
br label %bb.4

bb.4:
br label %bb.1

}

define void @main() {
prologue:
%l.0 = alloca {i8*, i64, i64}
br label %bb.0

bb.0:
%l.1 = call {i8*, i64, i64} @mk_vec$LT$i8$GT$()
br label %bb.1

bb.1:
store {i8*, i64, i64} %l.1, {i8*, i64, i64}* %l.0
%l.3 = bitcast {i8*, i64, i64}* %l.0 to {i8*, i64, i64}*
%l.2 = call {} bitcast(void({i8*, i64, i64}*, i8)* @push$LT$i8$GT$ to {}({i8*, i64, i64}*, i8)*)({i8*, i64, i64}* %l.3, i8 4)
br label %bb.2

bb.2:
%l.5 = bitcast {i8*, i64, i64}* %l.0 to {i8*, i64, i64}*
%l.4 = call i8* @at$LT$i8$GT$({i8*, i64, i64}* %l.5, i64 0)
br label %bb.3

bb.3:
ret void

}


